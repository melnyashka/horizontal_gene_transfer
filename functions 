#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jul 23 16:20:08 2018

@author: samuelnordmann
"""
import numpy as np
import scipy
from scipy import stats
import pandas as pd

def resc_x(x):#rescale a trait to a position in the vector X
    return int(x/dX)

#Defining the events of death, birth, and HT

def death(n,t,x):#at time t, this function kills an individual x in the population n
    n=n
    n[t][resc_x(x)]-=1#modifies in place
    #return n


def mutation_kernel(x):#Define the mutation kernel centered at x
    X_weighted= list(map(lambda z: np.exp(-((x-z)/sigma)**2), X))
    S=sum(X_weighted)
    return list(map(lambda z: z/S, X_weighted))

def birth(n,t,x):#Process of birth of an individual x at time t in the population n
    n=n
    mutation=np.random.binomial(1, p, size=None)==0#Boolean, true if mutation.
    if mutation:
        x_new=np.random.choice(X, size=None, replace=False, p=mutation_kernel(x))#choice of the new trait
        n[t][resc_x(x_new)]+=1 #new individual
    else:#If no mutation
         n[t][resc_x(x)]+=1
    #return n




def HT_kernel(Ntot,x):#Defining the kernel of HT transfer
    X_weighted=list(map(lambda y: horizontal_transfer(x, y, Ntot), X))
    S=sum(X_weighted)
    return list(map(lambda z: z/S, X_weighted))


def HT(n,Ntot,t,x):#in a population n, with Ntot total individuals, at time t and individual with trait x is subject to a Horizontal transfer
    x_new=np.random.choice(X, size=None, replace=False, p=HT_kernel(Ntot,x))
    n[t][resc_x(x_new)]+=1
    n[t][resc_x(x)]-=1
    #return n




















def flambda(n,Ntot,t,x):#Return the (lambda_b,lambda_d,lambda_HT), parameters of the exponential laws. n is N the population, Ntot is the total size
    
    HT_tot=0 #We compute the total transfer rate, i.e the sum over y of tau(x,y)/(beta+mu*Ntot)
    for y in range(nX):
        HT_tot+=horizontal_transfer(x, y, Ntot)
        
    lambda_x_tot=b(x)+death_prob(x, Ntot)+HT_tot(x, Ntot)#Total lambda
    return b(x)/lambda_x_tot,death_prob(x, Ntot)/lambda_x_tot,HT_tot(x, Ntot)/lambda_x_tot#(lambda_b, lambda_d, lambda_HT)

def event_individual(n,Ntot,t,x):#for a fixed individual (with trait x at time t in the population n) pick three times (T_b, T_d, T_HT) with the exponential law (lambda_b, lambda_d, lambda_HT) corresponding to the events of death, birth and HT. We only keep the first event (i.e the minimal time), and we return the time and type fof the first event.
    lambda_b, lambda_d, lambda_HT=flambda(n,t,x)#we recover the parameters of the exponential laws
    T_b, T_d, T_HT=np.random.exponential(scale=lambda_b, size=None), np.random.exponential(scale=lambda_d, size=None),np.random.exponential(scale=lambda_HT, size=None)#Compute the three random times
    T_first= min (T_b,T_d,T_HT)#taking the first event
    Type_Event='birth'#determining what kind of event the first event is.
    if T_d==T_first:
        Type_Event='death'
    elif T_HT==T_first:
        Type_Event='HT'
    return (T_first,Type_Event)

dT2=dT #interval of time in which events are taken into account.
def event_collection(n,Ntot,t):#for each individual in population n, we simulate the first event. Then we return the list of all the events for all individuals that happen bedore dT2.
    collection=pd.DataFrame(columns=['Time','Event','Trait'])
    for x in X:#for each trait
        for i in range(n[resc_x(x)]):#for each individual of trait x
            (T_first,Type_Event)=event_individual(n,Ntot,t,x)#we recover the first event of this individual
            collection.append(pd.DataFrame([[T_first], [Type_Event],[x]], columns=['Time','Event','Trait']))#We add the new row with the new event
    return collection.loc[collection['Time']<dT2] #return the list with only times that are < dT2.



    #collection_Event=[]#initialization, empty list
    #collection_Time=[]#initialization, empty list
            #collection_Time.append(T_first)#We keep track of the time when it happens
            #collection_Event.append([x,Type_Event])#We keep track of the type of event. More previsely, [trait, Type of Event]
    #return[x for _,x in sorted(zip(collection_Time,collection_Event))]#We sort the list 







#def evolution(n,Ntot,t)#take the 10 first elements of event_collection

